* Overview
This is my init rewrite. A vanilla init.el was getting out of control and
maybe going back to a literate style with org will help. If this gets to be
annoying (for instance not being able to just eval buffer) I can always try
outline mode.

This is a work in progress (but isn't every init?). I'm not sure everything works like it did in my old
init (nor am I sure I want it to). So not everything is likely to be 100% yet.

* TODOS
** TODO Line numbers don't show up in org mode.
** TODO better organization

* Basics
** OS X
   I'm used to things a certain way. Also, unlike a lot of Emacs users I
   prefer to use CapsLock as meta instead of Ctrl. Which I set via the
   OSX pref pane. The original reason for that was that on mechanical
   keyboards dropping the your hand and hitting Ctrl was easy, now it's
   just habit.

  #+begin_src emacs-lisp
    (setq mac-option-modifier 'super)
    (setq mac-command-modifier 'meta)
    (setq mac-pass-command-to-system 't)

    (define-key global-map [?\s-v] 'yank)
    (define-key global-map [?\s-c] 'kill-ring-save)
    (define-key global-map [?\s-x] 'kill-region)

    (setq select-enable-clipboard t)
  #+end_src
** Set Up A Convenient way to get to my config file
  #+begin_src emacs-lisp
    (defconst *install-dir* "~/jjgemacs/")

    (defun find-config ()
      "Edit config.org"
      (interactive)
      (find-file (concat *install-dir* "settings.org")))

    (global-set-key (kbd "C-c I") 'find-config)
  #+end_src

** Sensible Defaults
   Eventually I need to customize this and pull the defaults I actually
   care about into this init rather than relying on whatever version of
   sensible defaults I used the last time I reworked this file.

   For now I've checked in that version and I'll continue to use it as is:

  #+begin_src emacs-lisp
    (load-file (concat *install-dir* "sensible-defaults.el"))
    (sensible-defaults/use-all-settings)
    (sensible-defaults/use-all-keybindings)
    (sensible-defaults/backup-to-temp-directory)
  #+end_src
** Font

   I need better font management, setting the height like this seems like a bad
   pattern, maybe it should be in custom.el. For now though setting the font
   based on the detected screen resolution seems like it might work.

   For now checkingg the display width should be sufficient, if it's 1920 then
   we'll use the smaller font size.

#+begin_src emacs-lisp :results silent
  ;; fonts I'm playing with:
  ;; iosevka
  ;; Source Code Pro
  ;; Hack (150)
  ;; Fantasque Sans Mono
  (defvar *my-font-size* 140)
  (when (= (display-pixel-width) 1920)
    (setq *my-font-size* 110))
  (when (= (display-pixel-width) 3456)
    (setq *my-font-size* 100))
  (when (= (display-pixel-width) 3840)
    (setq *my-font-size* 120))
  (message (concat "Setting font to: " (number-to-string *my-font-size*)))
  (defvar *my-font* "")
  (setq *my-font* "Hack")
  (set-face-attribute 'default nil :font *my-font* :height *my-font-size*)
  (set-frame-font *my-font* nil t)
#+end_src

** Some Initial UI Changes

   Getting rid of some of the default ui elements that just get in the way: tool
   bar, menu bar, scroll bar, and a mini scrollbar that appears in minibuffers.

  #+begin_src emacs-lisp
    (tool-bar-mode 0)
    (menu-bar-mode 0)
    (scroll-bar-mode -1)

    (set-window-scroll-bars (minibuffer-window) nil nil)
  #+end_src

** Package Management
Package management has been moved to init.el, prior to tangling this file. The
reason is that I need to be able to use a more current version of org, which
means pulling in org prior to this file being processed. Otherwise I get the
built in version which as of Emacs 27.1 is outdated to the point where org-roam
doesn't work.

** Look and feel
   Pull in doom themes to use the bold, italic, and doom-vibrant.

  #+begin_src emacs-lisp
    (use-package doom-themes
      :straight t
      :config
      (progn
	(setq doom-themes-enable-bold t
	      doom-themes-enable-italic t)
	(load-theme 'doom-vibrant t)))
  #+end_src

  hl-line highlights the line at current point

  #+begin_src emacs-lisp
    (use-package hl-line
      :straight t
      :config
      (global-hl-line-mode))
  #+end_src

  Rainbow delimeters, always.

  #+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :straight t)
  #+end_src
** All the icons
#+begin_src emacs-lisp
  (use-package all-the-icons
    :straight t)
#+end_src
** Projectile

I'm not sure what exactly happened here, but I believe when I installed Rustic
an older version of project.el was installed somehow but not loaded? Which
doesn't make real sense, rustic requires project but the version in the straight
repos was up to date (at least as far as master). Still explicitly requiring the
project package makes the problem go away...
#+begin_src emacs-lisp :results silent
  (use-package project
    :straight t)
#+end_src

#+begin_src emacs-lisp
  (use-package projectile
    :straight  t
    :config
    (projectile-global-mode)
    (setq projectile-enable-caching t))
#+end_src

Some additional bindings.
#+begin_src emacs-lisp :results silent
  (global-set-key (kbd "C-c p p") #'projectile-switch-project)
  (global-set-key (kbd "C-c p f") #'projectile-find-file)
  (global-set-key (kbd "C-c p t") #'projectile-toggle-between-implementation-and-test)
  (global-set-key (kbd "C-c p b") #'projectile-switch-to-buffer)
#+end_src
** Search
ag for searching

Make sure The [[https://github.com/ggreer/the_silver_searcher][Silver Searcher]] is installed.
#+begin_src emacs-lisp
  (use-package ag
    :straight t
    :commands (ag ag-regexp ag-project))
#+end_src

Binding to use ag for project grep.
#+begin_src emacs-lisp
(global-set-key (kbd "C-c p s g") #'ag-project)
#+end_src
** In Buffer Completion
Company mode for completions.
#+begin_src emacs-lisp
  (use-package company
    :straight t)
  (global-company-mode)
#+end_src

Try out company box for icons
#+begin_src emacs-lisp :results silent
  (use-package company-box
    :straight t
    :hook (company-mode . company-box-mode))
#+end_src

*** TODO slime company mode
** Emacs Completion Framework
I'm still using Helm though another stab at Ivy could be in the near future.
#+begin_src emacs-lisp
  (defun helm-hide-minibuffer-maybe ()
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))

  (use-package helm
    :straight t
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("C-x f" . helm-recentf)
           ("M-y" . helm-show-kill-ring)
           ("C-x b" . helm-buffers-list))
    :bind (:map helm-map
                ("M-i" . helm-previous-line)
                ("M-k" . helm-next-line)
                ("M-I" . helm-previous-page)
                ("M-K" . helm-next-page)
                ("M-h" . helm-beginning-of-buffer)
                ("M-H" . helm-end-of-buffer)
                ("TAB" . helm-execute-persistent-action)
                ("<tab>" . helm-execute-persistent-action)
                ("C-z" . helm-select-action))
    :config (progn
              (setq helm-buffers-fuzzy-matching t)
              (setq helm-echo-input-in-header-line t)
              (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
              (helm-mode 1)))

  (use-package helm-descbinds
    :straight t
    :bind ("C-h b" . helm-descbinds))

  (use-package helm-swoop
    :straight t
    :bind (("M-m" . helm-swoop)
           ("M-M" . helm-swoop-back-to-last-point))
    :init
    (bind-key "M-m" 'helm-swoop-from-isearch isearch-mode-map))

  (use-package helm-ag
    :straight helm-ag
    :bind ("M-p" . helm-projectile-ag)
    :commands (helm-ag helm-projectile-ag)
    :init (setq helm-ag-insert-at-point 'symbol
                helm-ag-command-option "--path-to-ignore ~/.agignore"))

   (use-package helm-company
     :straight t)

  (use-package helm-projectile
    :straight t
    :config
    (helm-projectile-on))
#+end_src
** Dashboard
I don't really end up using the dashboard, but I'm going to keep it for now.
#+begin_src emacs-lisp
  (use-package dashboard
    :straight t
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-items '((recents . 5)
                            (projects . 10)
                            (bookmarks . 5))))
#+end_src
** Key Chord mode
Key chord lets me define quick key presses to call functions. This just pulls in
the package, there will be a `key-chord-define-global` in the appropriate
sections.

#+begin_src emacs-lisp
  (use-package key-chord
    :straight t
    :config (key-chord-mode 1))
#+end_src
** Popwin
Popwin handles the annoying pop up buffers.
#+begin_src emacs-lisp
  (use-package popwin
    :straight t
    :config
    (setq display-buffer-alist '((popwin:display-buffer-condition popwin:display-buffer-action))))
#+end_src
** Modeline
*** Doom modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :straight t
    :hook (after-init . doom-modeline-mode)
    :init
    (setq doom-modeline-minor-modes (featurep 'minions)))
#+end_src
*** Minions
Provides a dropdown menu in the modeline.
#+begin_src emacs-lisp
  (use-package minions
    :straight t
    :config (minions-mode 1))
#+end_src
** Journal
I keep starting and stopping journals, but it's just a good damn idea for work
so trying again.
#+begin_src emacs-lisp
  (defun get-journal-file-yesterday ()
    "Gets filename for yesterday's journal entry."
    (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
           (daily-name (format-time-string "%Y%m%d" yesterday)))
      (expand-file-name (concat org-journal-dir daily-name))))

  (defun journal-file-yesterday ()
    "Creates and load a file based on yesterday's date."
    (interactive)
    (find-file (get-journal-file-yesterday)))

  (use-package org-journal
    :straight t
    :bind (("C-c t" . org-journal-new-entry)
           ("C-c y" . journal-file-yesterday))
    :custom
    (org-journal-dir "~/.journal/")
    (org-journal-file-format "%Y%m%d")
    (org-journal-date-format "%e %b %Y (%A)")
    (org-journal-time-format ""))
#+end_src
** Misc
A bunch of stuff that was sitting around loose in my old init. I should review
these to see what should stay and what shouldn't.

#+begin_src emacs-lisp
  (save-place-mode 1)
  (set-default 'truncate-lines 1)
  (setq ring-bell-function 'ignore)
  (winner-mode t)
  (blink-cursor-mode -1)

  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setq fci-rule-column 100)
#+end_src

*** Paren mode with better highlighting
I'm not sure this is even strictly necessary but since it was in the old init
I'll keep it.
#+begin_src emacs-lisp
  (require 'paren)
  ;;(set-face-background 'show-paren-match "#aaaaaa")
  (set-face-foreground 'show-paren-match "#f54949")
  (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
#+end_src

*** Backup and Save Management
Why did I do this? I don't know, but I don't want to get rid of it until I
remember.
#+begin_src emacs-lisp
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*", temporary-file-directory t)))
#+end_src
*** Don't use tabs
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src
*** Expand Region
#+begin_src emacs-lisp
  (use-package expand-region
    :straight t
    :bind ("M-@" . er/expand-region))
#+end_src

*** String Manipulation Library

#+begin_src emacs-lisp :results silent
  (use-package s
    :straight t)
#+end_src
*** Compat
I've run into trouble getting compat before, this time it was because I was
trying to set up forge.

#+begin_src emacs-lisp :results silent
  (use-package compat
    :straight (compat :type git :host github :repo "phikal/compat.el"))
#+end_src
* General Tools
** Treemacs
#+begin_src emacs-lisp
  (use-package treemacs
    :straight t
    :defer t
    :bind
    (:map global-map
           ("M-0"       . treemacs-select-window)
           ("C-x t t"   . treemacs)))
#+end_src

** Neotree

#+begin_src emacs-lisp :results silent
  (use-package neotree
    :straight t)
#+end_src
** Restclient Mode
Can't live without restclient mode, way too useful.

#+begin_src emacs-lisp
  (use-package restclient
    :straight (restclient :type git :host github :repo "pashky/restclient.el"))
#+end_src

Restclient jq doesn't come with the package in melpa so we need a separate recipe for that.

#+begin_src emacs-lisp
  (use-package restclient-jq
    :straight (restclient-jq :type git :host github :repo "pashky/restclient.el"))
#+end_src

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.restclient\\'" . restclient-mode))
#+end_src
** Ace Window
Window switching made easy via Ace Window.

#+begin_src emacs-lisp
  (use-package ace-window
    :straight t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))

  (key-chord-define-global "qq" 'ace-select-window)
#+end_src

Replace the normal window switch with ace-select window.

#+begin_src emacs-lisp :results silent
(global-set-key (kbd "C-x o") 'ace-select-window)
#+end_src

** Org Mode

   First things first, require org tempo to get the easy templates back. This
   enables stuff like '<s tab' to create source blocks. Not sure when this
   changed so I'm going to make the check below 27.2.

  #+begin_src emacs-lisp
    (when (version<= "27.1" emacs-version)
        (require 'org-tempo))
  #+end_src

  Org bullets please.
  #+begin_src emacs-lisp
    (use-package org-bullets
      :straight t
      :config
      (add-hook 'org-mode-hook #'org-bullets-mode))
  #+end_src

  Same here, when I'm on emacs <= 27.2 this doesn't work.

  #+begin_src emacs-lisp
    (when (version<= "27.1" emacs-version)
        (add-hook 'org-mode-hook 'org-indent-mode))
  #+end_src

  Org Babel setup. I haven't checked that all these work when moving to this new
  init. Also that ob-restclient load can probably be handle better.

  #+begin_src emacs-lisp
    (use-package ob-kotlin
      :straight (ob-kotlin :type git :host github :repo "zweifisch/ob-kotlin"))
  #+end_src

  #+begin_src emacs-lisp
    (use-package ob-typescript
      :straight t)
  #+end_src
  #+begin_src emacs-lisp :results silent

        (use-package ob-go
        :straight t)
          ;; TODO TEMPORARY I need a solution for managing non-package elisp files
        ;; this requires manually putting the restclient code in the search path
        ;; TODO this can probably be a gitsubmodule ... hey change this to use straight
        (load-file (concat *install-dir* "ob-restclient.el"))
        (require 'ob-restclient)
        (require 'ob-go)
        (require 'ob-clojure)
        (require 'ob-js)
        (require 'ob-groovy)
        (require 'ob-kotlin)
        (require 'ob-typescript)

        (with-eval-after-load 'org
          (org-babel-do-load-languages 'org-babel-load-languages
                                                               '((shell		.	t)
                                                                 (lisp		.	t)
                                                                 (clojure	.	t)
                                                                 (sql		.	t)
                                                                 (python	.	t)
                                                                 (go		.	t)
                                                                 (sql           .       t)
                                                                 (kotlin        .       t)
                                                                 (typescript    .       t)
                                                                 (scheme        .       t)
                                                                 (js		.	t)
                                                                 (restclient	.	t)
                                                                 (groovy        .       t)
                                                                 (dot . t)
    )))

        (setq org-babel-clojure-backend 'cider)

  #+end_src


Setting up org roam to get my notes in order.

#+begin_src emacs-lisp :results nil
  (use-package org-roam
    :straight t
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/roam-notes")
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert))
    :config
    (org-roam-setup))
#+end_src

#+RESULTS:
: org-roam-node-insert

*** Logging done in org mode
#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

*** Ob async
#+begin_src emacs-lisp
  (use-package ob-async
    :straight (ob-async :type git :host github :repo "astahlman/ob-async"))
#+end_src
** Magit
#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :bind (("C-x g" . magit-status)))
#+end_src

Controlling how magit status opens.
#+begin_src emacs-lisp
  (setq magit-display-buffer-function
        (lambda (buffer)
          (display-buffer
           buffer (if (and (derived-mode-p 'magit-mode)
                           (memq (with-current-buffer buffer major-mode)
                                 '(magit-process-mode
                                   magit-revision-mode
                                   magit-diff-mode
                                   magit-stash-mode
                                   magit-status-mode)))
                      nil
                    '(display-buffer-same-window)))))
#+end_src

#+begin_src emacs-lisp :results nil
  (use-package forge
    :straight t
    :after magit)
#+end_src

#+begin_src emacs-lisp :results nil
  (use-package code-review
    :straight t
    :after magit)
#+end_src

#+RESULTS:

** Git Gutter
#+begin_src emacs-lisp
  (use-package git-gutter+
    :straight t
    :init (global-git-gutter+-mode))
#+end_src
** Exec path from shell
Use the system env variables in Emacs.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

** Which Key
Gives you that pop up showing completions for partially entered commands.
#+begin_src emacs-lisp
  (use-package which-key
   :straight t)
  (which-key-mode)
  (which-key-setup-minibuffer)
#+end_src

** Avy
Jump around the buffer by key press.

#+begin_src emacs-lisp
  (use-package avy
    :straight t
    :bind (("C-'" . avy-goto-char-timer)
           ("C-:" . avy-goto-line)))

  (key-chord-define-global "sf" 'avy-goto-char-2)
#+end_src
** Midnight Mode
Runs the CleanBufferList but can run arbitrary code.
#+begin_src emacs-lisp
  (require 'midnight)
  (midnight-delay-set 'midnight-delay "12:00am")
#+end_src
** YA Snippet
I included ya snippet in my last config, but never really dug in. Keeping it
because I'm pretty sure it'll be useful.
#+begin_src emacs-lisp
  (use-package yasnippet
    :straight t
    :config
    (yas-global-mode 1))
#+end_src
** Deft
Not sure I want to use this anymore but I'm going to keep it for now.
#+begin_src emacs-lisp
  (use-package deft
    :straight t
    :config
    (setq deft-directory "~/notes")
    (setq def-recursive t)
    (setq deft-auto-save-interval 300.0)
    (setq deft-org-mode-title-prefix t)
    (setq deft-use-filename-as-title t)
    (setq deft-default-extension "org"))
#+end_src
** Ox Hugo
I was using this to manage my blog, which still exists, but since I didn't take
good notes on how I ran it I need to come back to this and make sure everything
still works.
#+begin_src emacs-lisp
  (use-package ox-hugo
    :straight t
    :after ox)
#+end_src
** How Do You
This is supposed to help you search across the various SO type sites to get
answers. I should use it more or delete it.
#+begin_src emacs-lisp
  (use-package howdoyou
    :straight t)
#+end_src
** Free Keys
Shows what key bindings are open in a particular mode.

#+begin_src emacs-lisp
  (use-package free-keys
    :straight t)
#+end_src
** Docker
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :straight t
    :mode "\\Dockerfile*//")
#+end_src

#+begin_src emacs-lisp :results silent
  (use-package docker
    :straight t
    :bind ("C-c d" . docker))
#+end_src

** Col-Highlight
Working with yaml is a pain in the ass without this:
Might drop this...
#+begin_src emacs-lisp
  (use-package col-highlight
    :straight (col-highlight :type git :host github :repo "emacsmirror/col-highlight"))
#+end_src

** Highlight indentation
#+begin_src emacs-lisp
    (use-package highlight-indentation
      :straight (highlight-indentation :type git :host github :repo "antonj/Highlight-Indentation-for-Emacs")
      :config
      (set-face-background 'highlight-indentation-current-column-face "#60646b")
      (set-face-background 'highlight-indentation-face "#2c2e30"))
#+end_src

** Smart Shift
#+begin_src emacs-lisp
  (use-package smart-shift
    :straight (smart-shift :type git :host github :repo "hbin/smart-shift"))
#+end_src
** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :straight t)
#+end_src

** Dumb Jump
Let's give dumb jump a try again.
#+begin_src emacs-lisp
  (use-package dumb-jump
    :straight t)
#+end_src
** UUID
I'm probably going to want to implement these myself at some point but for now
leveraging a lib on github will work. Provides a variety of functions but I'm
grabbing it mainly just to insert a random uuid into a buffer.
#+begin_src emacs-lisp
  (use-package uuidgen
    :straight (uuidgen :type git :host github :repo "kanru/uuidgen-el"))
#+end_src

** AJ Toggle
#+begin_src emacs-lisp
  (defun aj-toggle-fold ()
    "Toggle fold all lines larger than indentation on current line"
    (interactive)
    (let ((col 1))
      (save-excursion
        (back-to-indentation)
        (setq col (+ 1 (current-column)))
        (set-selective-display
         (if selective-display nil (or col 1))))))
  (global-set-key [(M C i)] 'aj-toggle-fold)
#+end_src
** Indentation Inference
When working with files you didn't write you might run into other indentation
offsets, this packages is supposed to infer based on the file.

#+begin_src emacs-lisp
  (use-package dtrt-indent
    :straight (dtrt-indent :type git :host github :repo "jscheid/dtrt-indent"))
#+end_src

** My Github Cloning Tool
#+begin_src emacs-lisp :results silent
  (load (locate-user-emacs-file "github.el") nil :nomessage)
#+end_src

** My Project creation tools
#+begin_src emacs-lisp :results silent
  (load (locate-user-emacs-file "my-projects.el") nil :nomessage)
#+end_src
** ejc-sql

#+begin_src emacs-lisp :results silent
  (use-package ejc-sql
    :straight t
    :commands
    (ejc-create-connection ejc-connect ejc-set-column-width-limit)
    :init
    (setq ejc-set-rows-limit 1000
          ejc-result-table-impl 'orgtbl-mode
          nrepl-sync-request-timeout 30)
    (push 'ejc-company-backend company-backends)
    (add-hook 'ejc-sql-minor-mode-hook
              (lambda ()
                (company-mode t))))
#+end_src

#+begin_src emacs-lisp :results silent
      (defun connect-to-tw-athena ()
        (interactive)
        (ejc-create-connection "TW Athena Conn"
                               :dependencies [[com.syncron.amazonaws/simba-athena-jdbc-driver "2.0.2"]]
                               :dbtype "awsathena"
                               :classname "com.simba.athena.jdbc.Driver"
                               :subprotocol "awsathena"
                               :subname "//athena.us-east-1.amazonaws.com:443/my_database;AwsCredentialsProviderArguments=default;AwsCredentialsProviderClass=com.simba.athena.amazonaws.auth.profile.ProfileCredentialsProvider;S3OutputLocation=s3://jayg-athena-query-holder/"))
#+end_src
** libvterm
#+begin_src emacs-lisp :results silent
  (use-package vterm
    :straight t)
#+end_src
** s3ed
Trial of package to explore s3 repositories:
TODO Figure out why this breaks...
#+begin_src emacs-lisp :results silent
  (use-package s3ed
    :straight t)
#+end_src

** Multiple Cursors
#+begin_src emacs-lisp :results silent
  (use-package multiple-cursors
    :straight t)
#+end_src
** Dot Env
#+begin_src emacs-lisp :results silent
  (use-package dotenv-mode
    :straight t)
#+end_src
** Jira

Ewww...

#+begin_src emacs-lisp :results silent
  (use-package org-jira
    :straight t)
#+end_src

#+begin_src emacs-lisp :results silent
  (when (not (file-directory-p "~/.org-jira"))
    (make-directory "~/.org-jira"))
#+end_src

Change or delete this if I switch jobs.
#+begin_src emacs-lisp :results silent
  (setq jiralib-url "https://tradeswell.atlassian.net/")
#+end_src

** Hippie Expand

Rebinding from dabbrev-expand to hippie expand.

#+begin_src emacs-lisp :results silent
  (global-set-key "\M-/" 'hippie-expand)
#+end_src
* Languages
** General
*** Smart Parens
#+begin_src emacs-lisp
  (use-package smartparens
    :straight t)

  (require 'smartparens-config)
#+end_src

Bindings that shouldn't be global but are for now.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-)") 'sp-forward-slurp-sexp) ;; this shouldn't be always set but for now if it gets me going
  (global-set-key (kbd "M-s") 'sp-splice-sexp)
#+end_src
*** Javascript
#+begin_src emacs-lisp :results nil
  (setq js-indent-level 2)
#+end_src

*** JSON
Extends the built in javascript mode iirc.
#+begin_src emacs-lisp
  (use-package json-mode
    :straight t)
#+end_src
*** Yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
    :straight t
    :mode ("\\.ya?ml\\'" . yaml-mode))
#+end_src

Not working yet...
#+begin_src emacs-lisp
(add-hook 'yaml-mode-hook 'highlight-indentation-mode)
(add-hook 'yaml-mode-hook 'highlight-indentation-current-line-mode)
(add-hook 'yaml-mode-hook 'smart-shift-mode)
(add-hook 'yaml-mode-hook 'flycheck-mode)
#+end_src
*** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :mode ("\\.md\\'" . markdown-mode))
#+end_src
*** LSP Mode
Installing this to experiment with Kotlin but likely to use elsewhere.
#+begin_src emacs-lisp :results silent
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :straight t
    :init (setq lsp-keymap-prefix "C-c l")
    :custom
    (lsp-idle-delay 0.6)
    :config (lsp-enable-which-key-integration t)
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))
  #+end_src

#+begin_src emacs-lisp :results silent
  (use-package lsp-ui
    :straight t
    :commands lsp-ui-mode)
#+end_src

Turning stuff on and off
#+begin_src emacs-lisp :results silent
(setq lsp-ui-doc-enable nil)
#+end_src

Try installing dap mode.

#+begin_src emacs-lisp :results silent
  (use-package dap-mode
    :straight t)
#+end_src

*** GraphQL
#+begin_src emacs-lisp
  (use-package graphql-mode
    :straight t)
#+end_src

#+RESULTS:

Going to pull in a library I found GraphQL.el. This should let me more easily
build queries for use in resclient mode, or better yet in an orgbabel block.

#+begin_src emacs-lisp
  (use-package graphql
    :straight (graphql :type git :host github :repo "vermiculus/graphql.el"))
#+end_src
*** repl-toggle
Clojure has this built into Cider I guess I'll want it elsewhere. We'll set it
up for elisp since it's built in here to allow us to just push to the alist to
add other languages.
#+begin_src emacs-lisp
  (use-package repl-toggle
    :straight (repl-toggle :type git :host github :repo "tomterl/repl-toggle")
    :init
    (setq rtog/fullscreen nil)
    (setq rtog/mode-repl-alist '((emacs-lisp-mode . ielm))))
#+end_src
** Lisp
*** Slime
#+begin_src emacs-lisp :results silent
  ;; (use-package slime
  ;;   :straight t
  ;;   :config
  ;;   (setq inferior-lisp-program "/usr/bin/sbcl")
  ;;   ;;(setq slime-contribs '(slime-fancy slime-asdf)) ;;taking out temporarily for clisp
  ;;   (setq slime-lisp-implementations
  ;;         '((sbcl ("/usr/bin/sbcl"))
  ;;           (clisp ("/usr/local/bin/clisp")))))
#+end_src

*** Sly
Going to try Sly for a bit instead of Slime.
#+begin_src emacs-lisp :results silent
      (use-package sly
        :straight t
        :config
        (setq inferior-lisp-program "/usr/bin/sbcl"))
#+end_src

*** Lisp hooks
#+begin_src emacs-lisp
  (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'lisp-mode-hook #'smartparens-mode)
  (add-hook 'lisp-mode-hook #'turn-on-smartparens-strict-mode)
  (add-hook 'lisp-mode-hook #'eldoc-mode)
  (add-hook 'lisp-mode-hook #'subword-mode)
#+end_src
*** Slime Hooks
#+begin_src emacs-lisp
  (add-hook 'slime-repl-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'slime-repl-mode-hook #'smartparens-mode)
  (add-hook 'slime-repl-mode-hook #'turn-on-smartparens-strict-mode)
#+end_src

** Prolog

Need to fill out more but to start, .pl files should be Prolog instead of Perl.
I still have a soft spot in my heart for Perl but I have zero plans to use it
again and if I do I don't mind switching the mode.

#+begin_src emacs-lisp :results silent
    (add-to-list 'auto-mode-alist '("\\.pl\\'" . prolog-mode))
#+end_src


No idea if this is going to work but I ran this in the shell:

#+begin_src bash
swipl -g "pack_install(debug_adapter)" -t halt
#+end_src

And supposedly this gives you the debugger?

#+begin_src emacs-lisp :results silent
(require 'dap-swi-prolog)
#+end_src

** Scheme
#+begin_src emacs-lisp
  (use-package geiser
    :straight t
    :custom
      (geiser-active-implementations '(guile mit))
      (geiser-set-default-implementation 'mit))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'scheme-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'scheme-mode-hook #'smartparens-mode)
  (add-hook 'scheme-mode-hook #'turn-on-smartparens-strict-mode)
#+end_src

** Racket
I'm not sure yet if I want to use racket-more or just plug racket into geiser.
From what I've read geiser gives a more SLIME like experience (which I'm used
to) but I'm going to take a crack and racket-mode as well.

#+begin_src emacs-lisp :results silent
  (use-package racket-mode
    :straight t)
#+end_src

#+begin_src emacs-lisp :results silent
  (add-hook 'racket-mode-hook #'smartparens-mode)
  (add-hook 'racket-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'racket-mode-hook #' turn-on-smartparens-strict-mode)
#+end_src
** Elisp
*** Hooks
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook #'smartparens-mode)
  (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook #'turn-on-smartparens-strict-mode)
  (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-mode)
  (add-hook 'emacs-lisp-mode-hook #'subword-mode)
#+end_src
** Clojure
Clojure mode.
#+begin_src emacs-lisp :results silent
    (use-package clojure-mode
      :straight t
      :config
      (add-hook 'clojure-mode-hook #'smartparens-mode)
      (add-hook 'clojure-mode-hook #'subword-mode)
      (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
      (add-hook 'clojure-mode-hook #'turn-on-smartparens-mode)
      (add-hook 'clojure-mode-hook #'turn-on-smartparens-strict-mode)
      (add-hook 'clojure-mode-hook 'lsp)
      (add-hook 'clojurescript-mode-hook 'lsp)
      (add-hook 'clojurec-mode-hook 'lsp)
      )
#+end_src

Gotta have cider.
#+begin_src emacs-lisp
  (use-package cider
    :straight t
    :config
    (setq nrepl-log-messages t)
  (add-hook 'cider-mode-hook #'eldoc-mode)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)
  (add-hook 'cider-repl-mode-hook #'smartparens-mode)
  (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'clojure-mode-hook #'turn-on-smartparens-strict-mode))
#+end_src

clj-refactor
#+begin_src emacs-lisp
  (use-package clj-refactor
    :straight t)

  (defun my-clj-refactor-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1)
    (cljr-add-keybindings-with-prefix "C-c C-m"))

  (add-hook 'clojure-mode-hook #'my-clj-refactor-hook)
#+end_src

I'm leaving out flycheck for now, I used to use joker but I'm not sure it's
necessary.
** C/C++
#+begin_src emacs-lisp :results silent
  (add-hook 'c-mode-hook 'lsp)
  (add-hook 'c++-mode-hook 'lsp)
#+end_src
** Groovy
I haven't used Groovy since waaaaay back other than in Jenkinsfiles.
*** Groovy Mode
#+begin_src emacs-lisp
  (use-package groovy-mode
    :straight t
    :config
    (add-to-list 'auto-mode-alist '("Jenkinsfile" . groovy-mode)))
#+end_src
** Golang
*** Imported from original init.. untested
#+begin_src emacs-lisp
  (defun my-go-mode-hook ()
    ;; Call Gofmt before saving
    (add-hook 'before-save-hook 'gofmt-before-save)
     (if (not (string-match "go" compile-command))
        (set (make-local-variable 'compile-command)
             "go build -v && go test -v && go vet")))

  (defun auto-complete-for-go ()
    (auto-complete-mode 1))

  (use-package go-mode
    :straight t
    :config
    (add-hook 'go-mode-hook 'my-go-mode-hook)
    (add-hook 'go-mode-hook 'auto-complete-for-go))
#+end_src

** Kotlin
Experimental, not sure if Kotlin is worth taking a run at in emacs or not with
IntelliJ having first class support :/.
#+begin_src emacs-lisp
  (use-package kotlin-mode
    :straight t
    :hook (kotlin-mode . lsp-deferred))
#+end_src

** Typescript
Require's lsp server for typescript.
npm install -g typescript-language-server
#+begin_src emacs-lisp
    (use-package typescript-mode
      :mode "\\.tsx?\\'"
      :straight t
      :hook (typescript-mode . lsp-deferred) ;; does this work correctly?
      :config (setq typescript-indent-level 2)
      :init
      (add-hook 'typerscript-mode-hook #'smartparens-mode)
      (add-hook 'typescript-mode-hook  #'turn-on-smartparens-strict-mode)
      (add-hook 'typescript-mode-hook (lambda ()
                                        (local-set-key (kbd "C-c C-z") 'rtog/goto-buffer-fun)))
  )
#+end_src

# TODO add raw js crap
# nodejs-repl
# run ts handles js and ts?

Parse ansi escape codes:

#+begin_src emacs-lisp
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (ansi-color-apply-on-region compilation-filter-start (point-max)))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+end_src

Pop to repl, depends on the pop-to-repl package set up above.

#+begin_src emacs-lisp
  (push '(typescript-mode . run-ts) rtog/mode-repl-alist)
#+end_src

#+begin_src emacs-lisp
  (use-package ts-comint
    :straight t
    :init
    (add-hook 'typescript-mode-hook
              (lambda ()
                (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
                (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
                (local-set-key (kbd "C-c b") 'ts-send-buffer)
                (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
                (local-set-key (kbd "C-c l") 'ts-load-file-and-go))))
#+end_src

** Python

I guess python mode comes pre-installed with emacs? Not sure whether to try an
LSP solution or Elpy, Elply for now.

#+begin_src emacs-lisp :results silent
  (use-package elpy
    :straight t
    :init
    (elpy-enable)
    (setq elpy-rpc-python-command "python3")
    (setq elpy-rpc-virtualenv-path 'current)
    )
#+end_src

** C/C++

#+begin_src emacs-lisp :results silent
  (setq company-clang-executable "clang-13")
#+end_src

** Rust

Rust is installed in the usual way via the rust up site. For now I'm trying the lsp mode for rust as detailed here: https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/

I clone the rust-analyzer projects into my usual directory structure ~/development/org/project, so in this case ~/development/rust-analyzer/rustanalyzer.

*** Rustic

#+begin_src emacs-lisp :results silent
  (use-package rustic
    :straight t
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu)
                ("M-?" . lsp-find-references)
                ("C-c C-c l" . flycheck-list-erros)
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c q" . lsp-workspace-restart)
                ("C-c C-c Q" . lsp-workspace-shutdown)
                ("C-c C-c s" . lsp-rust-analyzer-status))
    :hook (rustic-mode . lsp-deferred)
    :custom
      (lsp-rust-analyzer-cargo-watch-command "clippy")
    :config
    (setq rustic-format-on-save t)
    (add-hook 'rustic-mode-hook 'rk/rustic-mode-hook))

  (defun rk/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but don't try to
    ;; save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
    ;; no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t)))
#+end_src

*** Rustic hooks

#+begin_src emacs-lisp :results silent
    (add-hook 'rustic-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'rustic-mode-hook #'smartparens-mode)
    (add-hook 'rustic-mode-hook #'turn-on-smartparens-strict-mode)
#+end_src

#+RESULTS:

** LilyPond

Lilypond mode is installed in `/user/share/emacs/site-lisp` when installed via
apt-get (on Linux obviously). Not 100% ideal and at a minimum I should check if
it exists so new installations notify me to install it.
#+begin_src emacs-lisp :results silent
  (require 'lilypond-mode)
  (add-to-list 'auto-mode-alist '("\\.ly\\'" . LilyPond-mode))
#+end_src

Add a compile and save command.

** Java

* Misc Functions
** xml format function (stolen from Chris Gore)
#+begin_src emacs-lisp
  (defun xml-format ()
    (interactive)
    (save-excursion
      (shell-command-on-region
       (mark) (point)
       "xmllint --format --encode utf-8 -"
       (buffer-name) t)))
#+end_src

** decode a jwt token
#+begin_src emacs-lisp
  (defun decode-jwt ()
    (interactive)
    (let ((new-buff (get-buffer-create "decoded-jwt.js")))
      (save-excursion
        (shell-command-on-region
         (mark) (point)
         "jq -R 'split(\".\") | .[1] | @base64d | fromjson'"
         new-buff)
        (with-current-buffer new-buff
          (funcall 'javascript-mode))
        (switch-to-buffer new-buff))))
#+end_src

** open multiple eshell buffers
#+begin_src emacs-lisp
  ;; taken from here: https://wwvw.emacswiki.org/emacs/EshellMultipleEshellBuffers#:~:text=Multi%2Deshell,-multi%2Deshell.&text=It%20maintains%20a%20ring%20of,buffer%20in%20the%20shell%20ring.
  (defun eshell-new ()
    "Open a new instance of eshell."
    (interactive)
    (eshell 'N))
#+end_src

** Reading .env files
My current company makes use of .env files so having some functions to read them
in easily is useful. I'll come back and add code to toss out blank lines and
comment lines (starting with '#' later). This is my quick and dirty solution to
get existing env file data.

If this gets any more complicated I'll move it into its own package.

#+begin_src emacs-lisp
  (defun read-lines (path)
    (with-temp-buffer
      (insert-file-contents path)
      (split-string (buffer-string) "\n" t)))

  (defun env-var->alist-pair (string)
    "Takes a string of the form `var=val` and turns it into an
    alist pair''"
    (split-string string "=" t))

  (defun read-env-from-dotenv (dotenv-file var)
    "Returns a specific var from a .env file."
    (car
     (cdr
      (assoc var
             (mapcar (lambda (x)
                       (env-var->alist-pair x))
                     (read-lines dotenv-file))))))

#+end_src

* DB-Connections

I keep my db connections in a separate config that's not checked in.

#+begin_src emacs-lisp :results silent
  (load "~/.emacs-dbs.el")
#+end_src

Beginning of an tradeswell.el, for now it's just a file.
#+begin_src emacs-lisp :results silent
(load "~/development/tradeswell/tradeswell-emacs/tradeswell.el" t)
#+end_src

* Keep Custom out of this file
This should keep anything handled by customize out of this file.
#+begin_src emacs-lisp
  (setq custom-file (concat *install-dir* "custom.el"))
  (load custom-file)
#+end_src
